# GNU make

参考文档

1. 《GNU make中文手册》																											整理翻译：徐海兵
2. 《跟我一起写Makefile》                            																                作者：陈皓

## 1. 概述

* make是一个在软件开发中所使用的工具程序（Utility software），经由读取“makefile”的文件以自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。
* 许多现代软件的开发中（如Microsoft Visual Studio），集成开发环境已经取代make，但是在Unix环境中，仍然有许多工程师采用make来协助软件开发。



### 1.1 GNU make介绍

* make在执行时，需要一个命名为Makefile的文件。这个文件告诉make以何种方式编译源代码和链接程序。如果在你的工程中已经存在一个或着多个正确的Makefile。当对工程中的若干源文件修改以后，需要根据修改来更新可执行文件或者库文件，make会自动根据修改情况完成源文件的对应.o文件的更新、库文件的更新、最终的可执行程序的更新。

#### 1.1.1 相关知识

* 链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序(Linux环境下，可执行文件的格式为“ELF”格式)。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排(重定位),并链接系统相关文件(程序启动文件等)最终生成可执行程序。链接过程使用`GNU`的`ld工具`。
* 静态库：又称为文档文件(Archive File)。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员(.o文件)没有特殊的存在格式，仅仅是一个.o文件的集合。

* 动态库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成(Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件)。模块中各个成员的地址(变量引用和函数调用)都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段(多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据)。



## 2. Makefile规则

* 当使用make工具进行编译时，工程中以下几种文件在执行make时将会被编译(重新编译):

  * 所有的源文件没有被编译过，则对各个C源文件进行编译并进行链接，生成最后的可执行程序；

  * 每一个在上次执行make之后修改过的C源代码文件在本次执行make时将会被重新编译；

  * 头文件在上一次执行make之后被修改。则所有包含此头文件的C源文件在本次执行make时将会被重新编译。

### 2.1 执行

* Makefile文件的执行需要安装先make工具，此文仅涉及GNU make；

* 执行Makefile文件时在终端输入对应命令

  ```makefile
  #自动执行名称为makefile.mk或者Makefile.mk的文件
  make
  
  #执行指定的mk文件
  make -f XXX.mk
  ```



### 2.2 文件结构

* makefile文件执行时会从从上向下的第一个目标开始

  ```makefile
  target:prerequisites
  	command
  	...
  	...
  ```

* `target:`规则的目标。通常是最后需要生成的文件名或者为了实现这个目的而必需的中间过程文件名。可以是.0文件、也可以是最后的可执行程序的文件名等。另外，目标也可以是一个make执行的动作的名称，如目标“clean”

* `prerequisites:`规则的依赖。生成规则目标所需要的文件名列表。通常一个目标依赖于一个或者多个文件。

* `command:`规则的命令行。是规则所要执行的动作(任意的shell命令或者是可在shell下执行的程序)。它限定了make执行这条规则时所需要的动作。

* 一个规则可以有多个命令行，每一条命令占一行。注意：命令行必须以`[Tab]字符`开始而不是四个空格，`[Tab]字符`告诉make此行是一个命令行。make按照命令完成相应的动作。这也是书写Makefile中容易产生，而且比较隐蔽的错误。



### 2.2 调试

* makefile文件中有几种添加打印或者断点的方式

  * error函数，产生一个致命的错误并中断执行

    ```makefile
    $(error error test)    		#error test
    ```

  * warining函数，产生一个告警的信息不影响执行

    ```makefile
    $(warning warning test)		#warning test
    ```

  * info函数，产生一个调试的信息不影响执行

    ```makefile
    $(info info test)			#info test
    ```

  * echo函数，调用shell中的echo函数打印调式信息

    ```makefile
    @echo "echo test"			#echo test
    ```

    

## 3. 流程控制语句

* **需要特别注意的时在一个目标内使用时，前面不可以有`[tab]符号`，否则会被认为是`shell语句`；相关语句会传给shell解释器使用shell语法解析，导致报错**

* ifeq函数，判断参数是否不相等；相等为 true，不相等为 false

  ```makefile
  ifeq ($(a), $(b))
  	@echo "a = b"
  else
  	@echo "a != b"
  endif
  ```

* ifneq函数，判断参数是否不相等；不相等为 true，相等为 false

  ```makefile
  ifneq ($(a), $(b))
  	@echo "a = b"
  else
  	@echo "a != b"
  endif
  ```

* ifdef函数，判断变量的值是不是为空；有值为 true，没有值为 false

  ```makefile
  ifdef v
  	@echo "a = b"
  else
  	@echo "a != b"
  endif
  ```

* ifndef函数，判断变量的值是不是为空；没有值为 true，有值为 false

  ```makefile
  ifndef v
  	@echo "a = b"
  else
  	@echo "a != b"
  endif
  ```

  

## 4. 变量

* makefile中变量是一个名字，代表一个文本字符串，在Makefile的目标、依赖、命令中引用变量的地方，变量会被它的值所取代
* 变量的定义有两种方式,这两种风格的区别在于`定义方式`和`展开时机`



### 4.1 变量的引用

#### 4.1.1 变量的引用

* 变量的引用方式是`$(VARIABLE_NAME)`或者`${VARIABLE_NAME}`来引用一个变量的定义
* 变量引用的展开过程是**严格的文本替换**的过程

#### 4.1.2 变量的使用

* 变量名之中可以包含函数或者其它变量的引用，make在读入此行时根据已定义情况进行替换展开而产生实际的变量名
* 变量的定义值在长度上没有限制。变量定义较长时，可以将比较长的行分多个行来书写，除最后一行外行与行之间使用反斜杠（\）连接，表示一个完整的行
* 当引用一个没有定义的变量时，`make` 默认它的值为空

#### 4.1.3 追加变量值

* 一个通用变量在定义之后的其他一个地方，可以对其值进行追加

* 在 Makefile 中使用`+=`（追加方式）来实现对一个变量值的追加操作

  ```makefile
  # “another.o”添加到变量“objects”原有值的末尾，使用空格和原有值分开
  objects = main.o foo.o bar.o utils.o 
  objects += another.o
  
  # 大部分情况下等价于
  objects = main.o foo.o bar.o utils.o 
  objects := $(objects) another.o
  ```

  * 如果被追加值的变量之前没有定义，那么`+=`会自动变成`=`，此变量就被定义为一个递归展开式的变量

  * 直接展开式变量的追加过程：变量使用`:=`定义，之后`+=`操作将会首先替换展开之前此变量的值，然后在末尾添加需要追加的值，并使用`:=`重新给此变量赋值；递归展开式使用`=`赋值同理

    

### 4.2 递归展开式变量

* 递归展开式变量的定义是通过=或使用指示符define定义的

* 在引用的地方变量是严格的文本替换的过程，此变量值的字符串原模原样的出现在引用它的地方。

* 使用`=`赋值的变量在**在被引用的地方展开，包括此变量定义中对其他变量的引用**；如果是**在其他变量定义时被引用则不会展开**

  ```makefile
  ugh = Huh
  bar = $(ugh)
  foo = $(bar) 
  
  all:
  	@echo $(foo)			#Huh
  
  # 1.$(foo)被替换为$(bar)
  # 2.$(bar)被替换为$(ugh)
  # 3.$(ugh)被替换为Hug
  # 整个替换的过程是在执行echo $(foo)时完成的
  ```

#### 4.2.1 优点

* 可以在变量定义时,引用其他的之前没有定义的变量(可能在后续部分定义,或者是通过make的命令行选项传递的变量)

  ```makefile
  CFLAGS = $(include_dirs) -O 
  include_dirs = -Ifoo -Ibar
  
  # “CFLAGS”会在命令中被展开为“-Ifoo -Ibar -O”
  # 而在“CFLAGS”的定义中使用了其后才定义的变量“include_dirs”
  ```
  

#### 4.2.2 缺点

* 第一个缺点：此风格的变量定义,可能会由于出现变量递归定义而导致make陷入到无限的变量展开过程中,最终使make执行失败

  ```makefile
  CFLAGS = $(CFLAGS) –O
  
  # 它将会导致 make 对变量“CFLAGS”的无限展过程中去（这种定义就是变量的递归定义）
  # 因为一旦后续同样存在对“CLFAGS”定义的追加，展开过程将是套嵌的、不能终止的（在发生这种情况时，make 会提# 示错误信息并结束）
  ```

* 第二个缺点：这种风格的变量定义中如果使用了函数，那么包含在变量值中的函数总会在变量被引用的地方执行（变量被展开时）



### 4.3 直接展开式变量

* `直接展开式变量`可以`避免递归式展开变量`的问题，变量值中对其他变量或者函数的引用在定义变量时展开，所以变量被定义后就是一个实际需要的文本串，其中不再包含任何变量的引用

  ```makefile
  x := foo 
  y := $(x) bar 
  x := later 
   
  # 就等价于：
  y := foo bar 
  x := later
  ```

* 与递归式展开变量不同的是，在变量在定义时就完成了对所引用的变量和函数的展开，所以不能实现对其后定义变量的引用



### 4.4 变量的替换引用

* 对于一个已经定义的变量，可以使用“替换引用”将其值中的后缀字符（串）使用指定的字符（字符串）替换

* 格式为`$(VAR:A=B)`或者`${VAR:A=B}`意思是替换变量`VAR`中所有`A`字符结尾的字为`B`结尾的字，“结尾”的含义是空格之前（变量值多个字之间使用空格分开）

  ```makefile
  foo := a.o b.o c.o 
  bar := $(foo:.o=.c)
  
  # foo = a.o b.o c.o
  # bar = a.c b.c c.c
  ```



### 4.5 变量的嵌套引用

* 一个变量名（文本串）之中可以包含对其它变量的引用。这种情况我们称之为“变量的套嵌引用”或者“计算的变量名”

  ```makefile
  x = y 
  y = z 
  a := $($(x))    # a = z
  
  # 1.变量引用“$(x)”被替换为变量名“y”（就是“$($(x))”被替换为了“$(y)”）
  # 2.“$(y)”被替换为“z”（就是 a := z）
  ```

  * 这个例子中`（a:=$($(x))）`所引用的变量名不是明确声明的，而是由`$(x)`扩展得到。这里`$(x)`相对于外层的引用就是套嵌的变量引用

* 递归变量的套嵌引用过程，也可以包含变量的修改引用和函数调用

  ```makefile
  x = variable1
  variable2 := Hello
  y = $(subst 1, 2, $(x))
  z = y
  a := $($($(z)))				# a := Hello
  
  # 1.“$($($(z)))”首先被替换为“$($(y))”
  # 2.之后再次被替换为 $($(subst 1,2,$(x))) ”
  # 3.“$(x)”的值是“ variable1 ”，所以有“ $($(subst 1,2,$(variable1)))”）
  # 4.函数处理之后为“$(variable2)”。之后对它在进行替换展开。最终，变量“a”的值就是“Hello”
  ```





## X. 操作符

### X.1 "?="操作符

* 只有在此变量之前没有赋值的情况下才会对这个变量进行赋值

  ```makefile
   ?= bar 
  # 其等价于：
  ifeq ($(origin FOO), undefined) 
  FOO = bar 
  endif
  ```

  

## 目标

## 宏

## 规则

### 多规则目标

### 双冒号规则

## 函数
