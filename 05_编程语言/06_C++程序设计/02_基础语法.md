# C++基础语法

> 本文档记录所有内容均以**C++11**标准为基础
>
> C++作为C语言的超集，大量语法规则与C语言相同，此部分内容在此省略

[TOC]

## 1. 引用

引用`reference`并不是对象而是为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的变量名

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

### 1.1 引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号`&`开头：

```c++
int i = 1024, i2 = 2048;    //i和i2都是int
int sr = i, r2 = i2;        //r是一个引用，与i绑定在一起，r2是int
int i3 = 1024, &r1 = i3;    //i3是int,r1是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;     //r3和r4都是引用
```

引用只能绑定在一个对象上，而不能是一个值或者计算式的结果

```c++
int &refVal4 =10;       //错误：引用类型的初始值必须是一个对象
double dval =3.14;
int &refVal5 =dval;     //错误：此处引用类型的初始值必须是int型对象
```

### 1.2 引用和指针的区别

指针和引用都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

* 程序为指针变量分配内存区域，而不为引用分配内存区域。

* 指针使用时要在前加 `*` ，引用可以直接使用。

* 引用在定义时就被初始化，之后无法改变；指针可以发生改变。 即引用的对象不能改变，指针的对象可以改变。

* 没有空引用，但有空指针。这使得使用引用的代码效率比使用指针的更高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。

* 对引用使用`sizeof`得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小。

* 理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针

    ```c++
    int **p //合法
    int &&p //非法
    ```

* `++`引用与`++`指针的效果不一样。
    例如就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。



## 2. const限定符

> **尽量以`const`，`enum`，`inline`替换`#define`**	--《Effective C++中文版 第三版》条款02

有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字**const**对变量的类型加以限定

### 2.1 `const`对象的特征

* 被const修饰的变量是一个常量，任何对其赋值的操作都将引发错误

    ```c++
    const int buf=125;
    buf=1;              //错误：试图向const对象写值
    ```

* `const`对象必须初始化，初始值可以是任意复杂的表达式：

    ```c++
    int get_size()
    {
        return 0;
    }
    
    const int i = get_size();     //正确：运行时初始化
    const int j = 42;             //正确：编译时初始化
    const int k;                  //错误：k是一个未经初始化的常量
    ```

* `const`对象可以在初始化时被使用

    ```c++
    int i =42;
    const int ci =i;    //正确：i的值被拷贝给了ci
    int j=ci;           //正确：ci的值被拷贝给了j
    ```

* 默认状态下`const`对象仅在文件内有效

    * 在链接期间，`c++`中`const`具有内部链接性，`c`中`const`默认外部链接性

    * 编译器将在编译过程中把用到该变量的地方都替换成对应的值，译器必须知道变量的初始值。如果程序包含多个文件，则每个用了`const`对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义
    * 如果需要在文件间共享这个对象，那么不管声明还是定义都添加`extern`关键字，这样只需定义一次就可以了

### 2.2 const的引用

可以把引用绑定到`const`对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci =1024;
const int &r1 =ci;  //正确：引用及其对应的对象都是常量
r1 =42;             //错误：r1是对常量的引用
int &r2 =ci;        //错误：试图让一个非常量引用指向一个常量对象，不能直接或是通过引用修改常量对象的值
```



## 3. auto类型说明符

`C++11`新标准引入了`auto`类型说明符，用它就能让编译器替我们去分析表达式所属的类型，和某种特定类型的说明符不同，`auto`让编译器通过初始值来推算变量的类型。

### 3.1注意事项

* `auto`定义的变量必须有初始值

* 使用`auto`也能在一条语句中声明多个变量，因为一条声明语句中只能有一个基本类型，所以该语句中所有变量的初始数据类型必须一样

  ```c++
  auto i = 0, *p = &i;		//正确：i是整数、p是整型指针
  auto sz = 0, pi = 3.14;		//错误：sz和pi的类型不一样
  ```

* 编译器推断出来的`auto`类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型使其更符合初始化规则

## 命名空间

假设这样一种情况，当一个班上有两个名叫 `Zara` 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。

同样的情况也出现在 `C++` 应用程序中。例如，您可能会写一个名为 `xyz()` 的函数，在另一个可用的库中也存在一个相同的函数 `xyz()`。这样，编译器就无法判断您所使用的是哪一个 `xyz()` 函数。

因此，引入了**命名空间**这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围

例如`std::cin`表示从标准输入中读取内容，此处使用作用域操作符`::`的含义是：编译器应该从操作符左侧名字的作用域中寻找右侧的这个名字，因此`std::out`的意思是是要使用命名空间`std`中的名字`cin`

### using声明

有了`using`声明就无需专门的前缀也可以使用所需的名字，`using`声明具有如下的形式

```c++
//using声明的形式
using namespace::name;

#include<iostream>
//using声明，当我们使用名字cin的时候，从命名空间std中获取它
using std:cin;

int main()
{
    int i;
    cin >> i;			//正确：cin和std::cin含义相同
    cout << i;			//错误：没有对应的using声明，必须使用完整的名字
    std::cout << i;		//正确：显示的从std中使用cout
    return 0;
}
```

